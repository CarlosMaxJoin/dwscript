#summary Describes the DWS dialect of Object Pascal.
#labels Featured

= Introduction =

DWScript language is an Object Pascal dialect, it borrows most elements from Delphi, FreePascal and Prism/Oxygene, though with specificities of its own.

For Pascal users, you'll find below a summary of difference so you can get started right way.

= Dialect Specificities =

== Memory Model ==

A *garbage collector* ensures that no script-objects or structures are leaked, however, you can invoke destructors explicitly. Attempts to access a destroyed object will fail with an exception and is "safe".

== Data Types ==

See LanguageTypes for more details.

DWScript base types are *Integer*, *Float*, *Boolean* and *String*.<br>
Optional base types are Variant, TComplex, TVector and TMatrix.

Classes, arrays (fixed-size and dynamic), records (with methods), enumerations, meta-classes, interfaces and delegates are supported too.

Dynamic arrays support a set of pseudo-methods and operators (Add, Delete, IndexOf, Length, SetLength in...), and are true reference types.

As of v2.2, sets, generics and closures are not yet supported.

== Statements ==

See LanguageStatements for more details.

 * All standard structured Pascal statements (if, while, for, repeat...) are supported with the exception of with, goto and label.
 * "Case of" statement support is generalized: it can operate on any data type.
 * "For...in" support as of v2.2 is limited to enumerations and arrays.

== Operators ==

See LanguageOperators for more details.

 * All standard Pascal operators are supported (+, `*`, <, mod, shl, etc.).
 * Compound assignment operators are supported too: +=, -=, etc.
 * The *implies* operator is supported.
 * Operators can be overloaded.

Since pointers don't exist in the language, the ^ and ^= operators are available for overloading.<br>
Note that compound operators are currently not allowed on properties, due to ambiguity (should "obj.Prop += val" mean "obj.Prop := Add(obj.Prop, val)" or "obj.Prop.Add(val)" ?).

== Code Structure ==

Code structure is essentially standard Pascal with the following specificities:
 * variables, constants and procedures can be declared inline.
 * begin/end is optional for main program code.
 * var, const and type keywords have to be explicit before any var or type declaration in the main program (var/const blocks are allowed in procedure, before the first begin).
 * methods can be implemented inline (in the class declaration).

Variables are guaranteed to always be initialized.

Variable declaration can feature an assignment, variable type can be inferred, for instance
{{{
var i := 20;
}}}
is equivalent to
{{{
var i : Integer;
i:=20;
}}}
as well as
{{{
var i : Integer := 20;
}}}

== Array constants ==

Array constants are delimited with square brackets [ ] and not parenthesis ( ). The syntax change was necessary to allow supporting inline static arrays definition, and make provisions for operators operating on arrays and future array comprehension extensions.

{{{
const a1 : array [0..2] of String = ['zero', 'one', 'two'];
var a2 : array [0..2] of String;
a2 := ['zero', 'one', 'two'];
}}}

== Contracts Programming ==

Contracts programming is supported with a syntax similar to the Oxygene language, procedures can have "require" and "ensure" sections, the "ensure" sections also support the "old" keyword.

== Constructors ==

Classic constructor syntax is supported, but you can also specify a default constructor and use the "new" keyword to instantiate classes.

Both lines of code below are equivalent:
{{{
obj := TMyObject.Create(parameter);
obj := new TMyObject(parameter);
}}}

== Delegates ==

Function pointers are unified, there is no distinction between standalone function and method pointers.

For instance the following code is valid:
{{{
type TMyFunction = function (i : Integer) : String;

var v : TMyFunction;

v := IntToStr;

v := someObject.SomeMethod;

v := somInterface.SomeMethod;
}}}
As long as the function or method prototype matches.

You can use the '@' operator to explicit a function reference to remove ambiguity.